# WarrantyWatch
WarrantyWatch is a miner warranty checker. It tackles a question: “Is this miner still under manufacturer warranty or not?” It lets users upload a list of serial numbers and it queries Bitmain, Whatsminer and Canaan and provides a report: which units are still covered, when coverage expires, and which are out of warranty. is useful for hosting companies and mining farm operators.

----

## WarrantyWatch: Open-Source Github Repo Now Available

https://github.com/Bitcoin-M-World/WarrantyWatch

WarrantyWatch is currently a desktop application (Java-based) built to help mining farm operators and hosting companies check warranty status across large inventories of miners. The workflow is simple: you start with an Excel spreadsheet that contains miner serial numbers, the tool finds the serial-number column automatically (either by spotting “serial” in the header or by matching serial-like patterns), and it produces a new Excel file that keeps all your original columns while adding a warranty expiration date column. If you run it in “Auto” mode, it can also add a detected miner type column so mixed inventories can be processed without you splitting files by manufacturer first. It’s designed for real-world batch processing, so it supports resuming a job where it left off, which is useful when you’re working with big lists or you get rate limited.

Under the hood, WarrantyWatch handles warranty checks differently depending on the manufacturer. For Bitmain and WhatsMiner it performs an online lookup using JSON-based endpoints. For Canaan it submits a form-style request and then parses the JSON response. For Alpha Miner, where no public API is assumed, it calculates the warranty expiration date by decoding time information embedded in the serial number format and applying the warranty duration rule. Because these services can throttle heavy usage, WarrantyWatch includes rate-limit handling: it recognizes “too many requests” responses, respects retry instructions when provided, and backs off before trying again. The goal is to let you process thousands of serials without manually babysitting retries.

The planned roadmap is a Python version that keeps the same core behavior (Excel in, Excel out, same manufacturer logic, same serial detection, same retry/backoff handling) but shifts the user experience to a web-based workflow. The proposed architecture is a FastAPI backend with a simple web UI using server-rendered templates. Users would upload an Excel file, pick a miner type (or use Auto), and then track progress while the job runs. When complete, the user downloads the updated spreadsheet with warranty data appended. The port is broken into clear modules so it’s easy to maintain and extend: manufacturer API clients (one per vendor), an Excel handler (reading, writing, preserving formatting where possible), and a serial parser that can validate and classify serial formats and support additional vendors later.

For integration into other people’s workflows, WarrantyWatch fits neatly into three common patterns. First is inventory management: export your asset list to Excel, run WarrantyWatch, then import the warranty expiration field back into your CRM, CMMS, or asset tracker. Second is repair and RMA triage: as machines arrive, capture serials into an intake sheet, run the check, then route in-warranty units toward RMA and out-of-warranty units to repair or parts harvesting. Third is ongoing operations: re-run WarrantyWatch periodically against the same inventory to flag devices approaching warranty end, helping you plan preventive swaps or prioritize burn-in and monitoring on borderline units. The future web version makes this even easier for teams because it becomes a shared internal tool instead of something that lives on one technician’s computer.

In short, today WarrantyWatch is a batch warranty checker with Excel automation, vendor-specific lookup logic, Auto detection, resume capability, and built-in protection against throttling. The roadmap is to preserve those exact strengths while making it easier to deploy, share, and operationalize through a lightweight Python web app that any team member can use from a browser.
